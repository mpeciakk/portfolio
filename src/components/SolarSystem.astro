<div id="solar-system" class="solar-system"></div>
<div id="planet-info" class="planet-info"></div>

<script>
  import * as THREE from "three";

  interface Planet {
    name: string;
    radius: number;
    distance: number;
    color: string;
    description: string;
    rotationSpeed: number;
    orbitSpeed: number;
    offset: number;
    icon: string;
    techStack: string[];
  }

  const planets: Planet[] = [
    {
      name: "Webworld",
      radius: 1.5,
      distance: 30,
      color: "#3498db",
      description:
        "Full Stack Engineering - Building scalable web applications and APIs",
      rotationSpeed: 0.01,
      orbitSpeed: 0.00005,
      offset: 0,
      icon: "üåê",
      techStack: ["React", "Node.js", "PostgreSQL", "Docker", "AWS"],
    },
    {
      name: "Mobile Core",
      radius: 1.2,
      distance: 40,
      color: "#2ecc71",
      description: "Native and Cross-Platform Mobile Development",
      rotationSpeed: 0.008,
      orbitSpeed: 0.00004,
      offset: Math.PI / 6,
      icon: "üì±",
      techStack: ["Flutter", "Swift", "Kotlin", "React Native"],
    },
    {
      name: "Kernel Abyss",
      radius: 1,
      distance: 50,
      color: "#e74c3c",
      description: "OS Development & Low-Level Programming",
      rotationSpeed: 0.006,
      orbitSpeed: 0.00003,
      offset: Math.PI / 7,
      icon: "üß†",
      techStack: ["C", "Assembly", "Rust", "Linux Kernel"],
    },
    {
      name: "GameGrid",
      radius: 1.3,
      distance: 60,
      color: "#f1c40f",
      description: "Game Engine Development & Game Programming",
      rotationSpeed: 0.009,
      orbitSpeed: 0.00002,
      offset: Math.PI / 8,
      icon: "üéÆ",
      techStack: ["C++", "OpenGL", "Unity", "Unreal Engine"],
    },
  ];

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000,
  );
  const renderer = new THREE.WebGLRenderer({
    antialias: true,
    alpha: true,
  });
  renderer.setSize(window.innerWidth, window.innerHeight);

  let planetMeshes: THREE.Mesh[] = [];
  let orbitLines: THREE.Mesh[] = [];
  let raycaster = new THREE.Raycaster();
  let mouse = new THREE.Vector2();
  let hoveredPlanet: Planet | null = null;
  let isZoomed = false;
  let originalCameraPosition = new THREE.Vector3(20, 10, 50);
  let originalCameraRotation = new THREE.Euler(-0.3, 0, -0.2);
  let cameraAnimation: number | null = null;
  let zoomedPlanet: Planet | null = null;
  let zoomedPlanetMesh: THREE.Mesh | null = null;

  const container = document.getElementById("solar-system");
  const infoContainer = document.getElementById("planet-info");
  if (container) {
    container.appendChild(renderer.domElement);
  }

  camera.position.copy(originalCameraPosition);
  camera.rotation.copy(originalCameraRotation);

  // Create starry background
  const starGeometry = new THREE.BufferGeometry();
  const starCount = 5000;
  const starPositions = new Float32Array(starCount * 3);
  const starSizes = new Float32Array(starCount);
  const starColors = new Float32Array(starCount * 3);

  for (let i = 0; i < starCount; i++) {
    // Random position in a sphere
    const radius = 100 + Math.random() * 900; // Stars between 100 and 1000 units away
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);

    const x = radius * Math.sin(phi) * Math.cos(theta);
    const y = radius * Math.sin(phi) * Math.sin(theta);
    const z = radius * Math.cos(phi);

    starPositions[i * 3] = x;
    starPositions[i * 3 + 1] = y;
    starPositions[i * 3 + 2] = z;

    // Random size between 0.1 and 0.5
    starSizes[i] = 0.1 + Math.random() * 0.4;

    // Random color with slight variations
    const brightness = 0.5 + Math.random() * 0.5;
    starColors[i * 3] = brightness;
    starColors[i * 3 + 1] = brightness;
    starColors[i * 3 + 2] = brightness;
  }

  starGeometry.setAttribute(
    "position",
    new THREE.BufferAttribute(starPositions, 3),
  );
  starGeometry.setAttribute("size", new THREE.BufferAttribute(starSizes, 1));
  starGeometry.setAttribute("color", new THREE.BufferAttribute(starColors, 3));

  const starMaterial = new THREE.PointsMaterial({
    size: 1,
    vertexColors: true,
    transparent: true,
    opacity: 0.8,
    sizeAttenuation: true,
  });

  const stars = new THREE.Points(starGeometry, starMaterial);
  scene.add(stars);

  const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
  const sunMaterial = new THREE.MeshBasicMaterial({
    color: 0xffff00,
    transparent: true,
    opacity: 0.8,
  });
  const sun = new THREE.Mesh(sunGeometry, sunMaterial);
  sun.position.set(0, 0, 0);
  scene.add(sun);

  const sunGlow = new THREE.Mesh(
    new THREE.SphereGeometry(12, 32, 32),
    new THREE.MeshBasicMaterial({
      color: 0xffff00,
      transparent: true,
      opacity: 0.2,
    }),
  );
  scene.add(sunGlow);

  planets.forEach((planet) => {
    const geometry = new THREE.SphereGeometry(planet.radius, 32, 32);
    const material = new THREE.MeshPhongMaterial({
      color: planet.color,
      shininess: 100,
    });
    const planetMesh = new THREE.Mesh(geometry, material);

    const angle = planet.offset;
    planetMesh.position.set(
      Math.cos(angle) * planet.distance,
      0,
      Math.sin(angle) * planet.distance,
    );
    planetMesh.userData = { planet };
    scene.add(planetMesh);
    planetMeshes.push(planetMesh);

    const orbitGeometry = new THREE.RingGeometry(
      planet.distance - 0.1,
      planet.distance + 0.1,
      512,
    );
    const orbitMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.1,
    });
    const orbitLine = new THREE.Mesh(orbitGeometry, orbitMaterial);
    orbitLine.rotation.x = Math.PI / 2;
    orbitLine.position.set(0, 0, 0);
    scene.add(orbitLine);
    orbitLines.push(orbitLine);
  });

  const ambientLight = new THREE.AmbientLight(0x404040);
  scene.add(ambientLight);
  const pointLight = new THREE.PointLight(0xffffff, 1, 100);
  pointLight.position.set(0, 0, 0);
  scene.add(pointLight);

  function onMouseMove(event: MouseEvent) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(planetMeshes);

    if (intersects.length > 0 && intersects[0]?.object?.userData?.planet) {
      const planet = intersects[0].object.userData.planet as Planet;
      if (hoveredPlanet !== planet) {
        hoveredPlanet = planet;
        updatePlanetInfo(planet);
      }
    } else if (hoveredPlanet !== null) {
      hoveredPlanet = null;
      updatePlanetInfo(null);
    }
  }

  function updatePlanetInfo(planet: Planet | null) {
    if (!infoContainer) return;

    if (planet) {
      infoContainer.innerHTML = `
        <div class="planet-details">
          <h2>${planet.icon} ${planet.name}</h2>
          <p>${planet.description}</p>
          <div class="tech-stack">
            ${planet.techStack.map((tech) => `<span class="tech">${tech}</span>`).join("")}
          </div>
        </div>
      `;
      infoContainer.style.opacity = "1";
    } else {
      infoContainer.style.opacity = "0";
    }
  }

  function zoomToPlanet(planet: Planet) {
    if (cameraAnimation) {
      cancelAnimationFrame(cameraAnimation);
    }

    const planetMesh = planetMeshes.find(
      (mesh) => mesh.userData.planet === planet,
    );
    if (!planetMesh) return;

    zoomedPlanet = planet;
    zoomedPlanetMesh = planetMesh;

    const startTime = Date.now();
    const duration = 2000; // 2 seconds animation
    const startPosition = camera.position.clone();
    const startRotation = camera.rotation.clone();

    function animateCamera() {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);

      // Ease in-out function
      const easeProgress =
        progress < 0.5
          ? 2 * progress * progress
          : -1 + (4 - 2 * progress) * progress;

      if (progress < 1 && planetMesh) {
        // Calculate current target position based on planet's current position
        const targetPosition = new THREE.Vector3();
        targetPosition.copy(planetMesh.position);
        targetPosition.y += planet.radius * 2;
        targetPosition.z += planet.radius * 3;

        // Calculate current target rotation
        const targetQuaternion = new THREE.Quaternion();
        targetQuaternion.setFromRotationMatrix(
          new THREE.Matrix4().lookAt(
            targetPosition,
            planetMesh.position,
            new THREE.Vector3(0, 1, 0),
          ),
        );
        const targetRotation = new THREE.Euler().setFromQuaternion(
          targetQuaternion,
        );

        // Interpolate position
        camera.position.lerpVectors(
          startPosition,
          targetPosition,
          easeProgress,
        );

        // Interpolate rotation
        camera.rotation.x = THREE.MathUtils.lerp(
          startRotation.x,
          targetRotation.x,
          easeProgress,
        );
        camera.rotation.y = THREE.MathUtils.lerp(
          startRotation.y,
          targetRotation.y,
          easeProgress,
        );
        camera.rotation.z = THREE.MathUtils.lerp(
          startRotation.z,
          targetRotation.z,
          easeProgress,
        );

        cameraAnimation = requestAnimationFrame(animateCamera);
      } else {
        cameraAnimation = null;
        isZoomed = true;
      }
    }

    animateCamera();
  }

  function zoomOut() {
    if (cameraAnimation) {
      cancelAnimationFrame(cameraAnimation);
    }

    zoomedPlanet = null;
    zoomedPlanetMesh = null;

    const startTime = Date.now();
    const duration = 2000;
    const startPosition = camera.position.clone();
    const startRotation = camera.rotation.clone();

    function animateCamera() {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);

      // Ease in-out function
      const easeProgress =
        progress < 0.5
          ? 2 * progress * progress
          : -1 + (4 - 2 * progress) * progress;

      if (progress < 1) {
        // Interpolate position
        camera.position.lerpVectors(
          startPosition,
          originalCameraPosition,
          easeProgress,
        );

        // Interpolate rotation
        camera.rotation.x = THREE.MathUtils.lerp(
          startRotation.x,
          originalCameraRotation.x,
          easeProgress,
        );
        camera.rotation.y = THREE.MathUtils.lerp(
          startRotation.y,
          originalCameraRotation.y,
          easeProgress,
        );
        camera.rotation.z = THREE.MathUtils.lerp(
          startRotation.z,
          originalCameraRotation.z,
          easeProgress,
        );

        cameraAnimation = requestAnimationFrame(animateCamera);
      } else {
        cameraAnimation = null;
        isZoomed = false;
      }
    }

    animateCamera();
  }

  function onPlanetClick(event: MouseEvent) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(planetMeshes);

    if (intersects.length > 0 && intersects[0]?.object?.userData?.planet) {
      const planet = intersects[0].object.userData.planet as Planet;
      if (isZoomed) {
        zoomOut();
      } else {
        zoomToPlanet(planet);
      }
    }
  }

  window.addEventListener("mousemove", onMouseMove);
  window.addEventListener("click", onPlanetClick);

  function animate() {
    requestAnimationFrame(animate);

    sunGlow.scale.set(
      1 + Math.sin(Date.now() * 0.001) * 0.1,
      1 + Math.sin(Date.now() * 0.001) * 0.1,
      1 + Math.sin(Date.now() * 0.001) * 0.1,
    );

    // Rotate stars slightly for a subtle twinkling effect
    stars.rotation.y += 0.0001;

    planetMeshes.forEach((mesh) => {
      const planet = mesh.userData.planet as Planet;
      mesh.rotation.y += planet.rotationSpeed;
      const angle = planet.offset + Date.now() * planet.orbitSpeed;
      mesh.position.set(
        Math.cos(angle) * planet.distance,
        0,
        Math.sin(angle) * planet.distance,
      );

      // If this is the zoomed planet and not in transition, update camera position to follow it
      if (
        isZoomed &&
        zoomedPlanet &&
        zoomedPlanetMesh === mesh &&
        !cameraAnimation
      ) {
        const cameraOffset = new THREE.Vector3(
          0,
          planet.radius * 2,
          planet.radius * 3,
        );
        camera.position.copy(mesh.position).add(cameraOffset);
        camera.lookAt(mesh.position);
      }
    });

    renderer.render(scene, camera);
  }

  animate();

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

<style>
  .solar-system {
    width: 100%;
    height: 100vh;
    position: fixed;
    top: 0;
    left: 0;
    z-index: -1;
    background: linear-gradient(to bottom, #000000, #0a0a2a);
  }

  .planet-info {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.7);
    padding: 20px;
    border-radius: 10px;
    color: white;
    max-width: 300px;
    transition: opacity 0.3s ease;
    opacity: 0;
    backdrop-filter: blur(5px);
  }

  .planet-details h2 {
    margin: 0 0 10px 0;
    font-size: 1.5em;
  }

  .planet-details p {
    margin: 0 0 15px 0;
    line-height: 1.4;
  }

  .tech-stack {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  .tech {
    background: rgba(255, 255, 255, 0.1);
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.8em;
  }
</style>
